#!/usr/bin/env node


/* eslint-disable @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unused-vars */

/**
 * Step 1: Check Token Existence and CSS Variable Definitions
 *
 * Checks every table and every token in documentation files to find:
 * - Tokens that do not exist
 * - CSS variables that are not defined
 * - CSS variables that are not generated by tokens
 */

import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

// Paths - resolve relative to workspace root
const workspaceRoot = path.resolve(__dirname, '../../../..')
const docsRoot = path.resolve(workspaceRoot, 'packages/docs-design-system/docs-design-token')
const cssPath = path.resolve(workspaceRoot, 'packages/lib-design-token/dist/css/light/variables.css')
const tokenSrcRoot = path.resolve(workspaceRoot, 'packages/lib-design-token/src/tokens')

// Categories to check
const categories = ['colors', 'spacing', 'typography', 'effects', 'motion']

// Load CSS variables
function loadCSSVariables() {
  if (!fs.existsSync(cssPath)) {
    console.error(`âŒ CSS file not found: ${cssPath}`)
    console.error('   Run: pnpm --filter @designgreat/lib-design-token run build')
    process.exit(1)
  }

  const cssContent = fs.readFileSync(cssPath, 'utf8')
  const cssVars = new Set()
  const matches = cssContent.match(/--dg-[^:]+/g)
  if (matches) {
    matches.forEach(v => cssVars.add(v))
  }

  return cssVars
}

// Extract token references from MDX content
function extractTokenReferences(content) {
  const tokens = new Set()

  // Match token references like {color.primary.DEFAULT} or color.primary.DEFAULT
  // Only match in proper contexts (code blocks, CopyableCode, table cells)
  // Exclude plain text mentions
  const tokenPatterns = [
    /\{([a-z]+\.[a-z0-9.]+)\}/gi,  // {color.primary.DEFAULT} - always valid
    /CopyableCode[^>]*>([a-z]+\.[a-z0-9.]+)</gi, // <CopyableCode>color.primary.DEFAULT</CopyableCode>
    /`([a-z]+\.[a-z0-9.]+)`/gi,     // `color.primary.DEFAULT` - in code blocks
    /tokens\.([a-z]+\.[a-z0-9.]+)/gi // tokens.color.primary.DEFAULT
  ]

  tokenPatterns.forEach(pattern => {
    let match
    while ((match = pattern.exec(content)) !== null) {
      const token = match[1]
      // Skip if it's just mentioned in plain text (like "Use color.text.link")
      // Only include if it's in a code context or table
      const context = content.substring(Math.max(0, match.index - 20), Math.min(content.length, match.index + match[0].length + 20))
      if (context.includes('CopyableCode') || context.includes('```') || context.includes('|') || context.includes('tokens.')) {
        tokens.add(token)
      }
    }
  })

  return tokens
}

// Extract CSS variable references from MDX content
function extractCSSVariableReferences(content) {
  const vars = new Set()

  // Match complete CSS variables only (not partial ones ending with -)
  // Match in contexts: code blocks, CopyableCode components, var() functions, or standalone
  // Exclude template literals like `var(--dg-spacing-px${padding})`
  const varPatterns = [
    /var\((--dg-[a-z0-9-]+)\)/gi,  // var(--dg-xxx) - but not var(--dg-xxx${...})
    /`(--dg-[a-z0-9-]+)`/gi,        // `--dg-xxx` - but not `--dg-xxx${...}`
    /CopyableCode[^>]*>(--dg-[a-z0-9-]+)</gi,  // <CopyableCode>--dg-xxx</CopyableCode>
    /style=\{\{[^}]*['"](--dg-[a-z0-9-]+)['"]/gi  // style={{...'--dg-xxx'}}
  ]

  varPatterns.forEach(pattern => {
    let match
    while ((match = pattern.exec(content)) !== null) {
      const varName = match[1] || match[0]
      // Filter out partial matches (ending with -)
      // Filter out template literal patterns (containing ${)
      if (!varName.endsWith('-') && !content.includes(`\`var(${varName}\${`)) {
        vars.add(varName)
      }
    }
  })

  return vars
}

// Convert token path to CSS variable name
function tokenToCSSVar(tokenPath) {
  // color.primary.DEFAULT -> --dg-color-primary-default
  // spacing.px1 -> --dg-spacing-px1
  // size.font.h1 -> --dg-size-font-h1

  const parts = tokenPath.split('.')
  const prefix = '--dg-'
  const converted = parts
    .map(part => {
      // Handle DEFAULT -> default
      if (part === 'DEFAULT') return 'default'
      // Convert camelCase to kebab-case
      return part.replace(/([A-Z])/g, '-$1').toLowerCase()
    })
    .join('-')

  return prefix + converted
}

// Check if token exists in source files

function checkTokenExists(tokenPath) {
  const parts = tokenPath.split('.')
  const category = parts[0]
  const fileName = parts[1] || 'index'

  // Try to find the token file

  const possiblePaths = [
    path.join(tokenSrcRoot, category, `${fileName}.js`),
    path.join(tokenSrcRoot, category, `${fileName}.ts`),
    path.join(tokenSrcRoot, category, 'index.js'),
    path.join(tokenSrcRoot, category, 'index.ts')
  ]

  // For now, we'll check if the CSS variable exists
  // A more thorough check would require parsing the JS files
  return true // Placeholder - will check via CSS variable
}

// Process a single MDX file
function processFile(filePath) {
  const content = fs.readFileSync(filePath, 'utf8')
  const relativePath = path.relative(docsRoot, filePath)

  const issues = []

  // Extract tokens and CSS variables
  const tokens = extractTokenReferences(content)
  const cssVars = extractCSSVariableReferences(content)
  const allCSSVars = loadCSSVariables()

  // Check each token
  tokens.forEach(token => {
    const expectedCSSVar = tokenToCSSVar(token)
    if (!allCSSVars.has(expectedCSSVar)) {
      issues.push({
        type: 'missing_css_var',
        token,
        expectedCSSVar,
        file: relativePath
      })
    }
  })

  // Check each CSS variable
  cssVars.forEach(cssVar => {
    if (!allCSSVars.has(cssVar)) {
      issues.push({
        type: 'undefined_css_var',
        cssVar,
        file: relativePath
      })
    }
  })

  // Check for partial CSS variable matches (ending with -) for review
  const partialMatches = []
  const partialPattern = /--dg-[a-z0-9-]+-/gi
  let match
  while ((match = partialPattern.exec(content)) !== null) {
    const partial = match[0]
    // Only report if it's not part of a complete variable
    if (!content.includes(partial.replace(/-$/, ''))) {
      partialMatches.push(partial)
    }
  }

  return { file: relativePath, tokens: Array.from(tokens), cssVars: Array.from(cssVars), issues, partialMatches: [...new Set(partialMatches)] }
}

// Main function
function main() {
  console.log('='.repeat(80))
  console.log('STEP 1: Token Existence and CSS Variable Verification')
  console.log('='.repeat(80))
  console.log()

  const allCSSVars = loadCSSVariables()
  console.log(`âœ… Loaded ${allCSSVars.size} CSS variables from ${path.relative(process.cwd(), cssPath)}`)
  console.log()

  const allIssues = []
  const allPartialMatches = []
  const fileResults = []

  // Process each category
  categories.forEach(category => {
    const categoryPath = path.join(docsRoot, category)
    if (!fs.existsSync(categoryPath)) {
      console.log(`âš ï¸  Category not found: ${category}`)
      return
    }

    // Find all MDX files recursively
    function findMDXFiles(dir) {
      const files = []
      const entries = fs.readdirSync(dir, { withFileTypes: true })

      entries.forEach(entry => {
        const fullPath = path.join(dir, entry.name)
        if (entry.isDirectory()) {
          files.push(...findMDXFiles(fullPath))
        } else if (entry.isFile() && entry.name.endsWith('.mdx')) {
          files.push(fullPath)
        }
      })

      return files
    }

    const mdxFiles = findMDXFiles(categoryPath)

    console.log(`\nðŸ“ ${category.toUpperCase()} (${mdxFiles.length} files)`)
    console.log('-'.repeat(80))

    mdxFiles.forEach(filePath => {
      const result = processFile(filePath)
      fileResults.push(result)

      if (result.issues.length > 0) {
        console.log(`\nâŒ ${result.file}`)
        result.issues.forEach(issue => {
          console.log(`   - ${issue.type}: ${issue.token || issue.cssVar || issue.expectedCSSVar}`)
          allIssues.push({ ...issue, file: result.file })
        })
      } else {
        console.log(`âœ… ${result.file} (${result.tokens.length} tokens, ${result.cssVars.length} CSS vars)`)
      }

      // Collect partial matches for review
      if (result.partialMatches.length > 0) {
        result.partialMatches.forEach(partial => {
          allPartialMatches.push({ partial, file: result.file })
        })
      }
    })
  })

  // Summary
  console.log('\n' + '='.repeat(80))
  console.log('SUMMARY')
  console.log('='.repeat(80))
  console.log(`Total files checked: ${fileResults.length}`)
  console.log(`Total tokens found: ${fileResults.reduce((sum, r) => sum + r.tokens.length, 0)}`)
  console.log(`Total CSS variables found: ${fileResults.reduce((sum, r) => sum + r.cssVars.length, 0)}`)
  console.log(`Total issues found: ${allIssues.length}`)
  console.log(`Total partial matches found: ${allPartialMatches.length}`)

  // Print partial matches for review
  if (allPartialMatches.length > 0) {
    console.log('\n' + '='.repeat(80))
    console.log('PARTIAL CSS VARIABLE MATCHES (FOR REVIEW)')
    console.log('='.repeat(80))
    console.log('These are partial CSS variable references that may need attention:')
    console.log()

    const byFile = {}
    allPartialMatches.forEach(({ partial, file }) => {
      byFile[file] ||= []
      byFile[file].push(partial)
    })

    Object.entries(byFile).forEach(([file, partials]) => {
      console.log(`\nðŸ“„ ${file}:`);
      [...new Set(partials)].forEach(partial => {
        console.log(`   - ${partial}`)
      })
    })
  }

  if (allIssues.length > 0) {
    console.log('\nâŒ ISSUES FOUND:')
    console.log('-'.repeat(80))

    const byType = {}
    allIssues.forEach(issue => {
      byType[issue.type] ||= []
      byType[issue.type].push(issue)
    })

    Object.entries(byType).forEach(([type, issues]) => {
      console.log(`\n${type} (${issues.length}):`)
      issues.forEach(issue => {
        console.log(`  - ${issue.file}: ${issue.token || issue.cssVar || issue.expectedCSSVar}`)
      })
    })

    process.exit(1)
  } else {
    console.log('\nâœ… No issues found! All tokens and CSS variables are valid.')
    process.exit(0)
  }
}

main()

